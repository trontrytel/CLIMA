using CLIMA.PlanetParameters
export PeriodicBC, NoFluxBC, InitStateBC, DYCOMS_BC, RayleighBenardBC, SurfaceDrivenBubbleBC

function atmos_boundary_flux_diffusive!(nf::CentralNumericalFluxDiffusive, bc,
                                        atmos::AtmosModel, 
                                        F‚Å∫,Y‚Å∫, Œ£‚Å∫,Œ±‚Å∫, 
                                        n‚Åª, 
                                        F‚Åª,Y‚Åª,Œ£‚Åª,Œ±‚Åª,
                                        bctype, t, 
                                        Y‚ÇÅ‚Åª, Œ£‚ÇÅ‚Åª, Œ±‚ÇÅ‚Åª)
  # Y  ‚â° state vars
  # Œ±  ‚â° auxiliary vars
  # Œ£  ‚â° diffusive vars
  # F  ‚â° flux
  # X‚ÇÅ ‚â° X at the first interior node
  # bctype ‚â° `wall` identifier
  # t ‚â° simulation time
  
  FT = eltype(F‚Å∫)
  atmos_boundary_state!(nf, bc, atmos, Y‚Å∫, Œ£‚Å∫, Œ±‚Å∫, n‚Åª,
                        Y‚Åª, Œ£‚Åª, Œ±‚Åª, bctype, t,
                        Y‚ÇÅ‚Åª, Œ£‚ÇÅ‚Åª, Œ±‚ÇÅ‚Åª)
  fill!(parent(F‚Å∫), -zero(FT))
  flux_diffusive!(atmos, F‚Å∫, Y‚Å∫, Œ£‚Å∫, Œ±‚Å∫, t)
end

#TODO: figure out a better interface for this.
# at the moment we can just pass a function, but we should do something better
# need to figure out how subcomponents will interact.
function atmos_boundary_state!(::Rusanov, f::Function, m::AtmosModel,
                               Y‚Å∫::Vars, Œ±‚Å∫::Vars, 
                               n‚Åª, 
                               Y‚Åª::Vars, Œ±‚Åª::Vars, 
                               bctype, t, _...)
  f(Y‚Å∫, Œ±‚Å∫, n‚Åª, Y‚Åª, Œ±‚Åª, bctype, t)
end

function atmos_boundary_state!(::CentralNumericalFluxDiffusive, f::Function,
                               m::AtmosModel, 
                               Y‚Å∫::Vars, Œ£‚Å∫::Vars, Œ±‚Å∫::Vars, 
                               n‚Åª, 
                               Y‚Åª::Vars, Œ£‚Åª::Vars,Œ±‚Åª::Vars, 
                               bctype, t, _...)
  f(Y‚Å∫, Œ£‚Å∫, Œ±‚Å∫, n‚Åª, Y‚Åª, Œ£‚Åª, Œ±‚Åª, bctype, t)
end

# lookup boundary condition by face
function atmos_boundary_state!(nf::Rusanov, bctup::Tuple, m::AtmosModel,
                               Y‚Å∫::Vars, Œ±‚Å∫::Vars, n‚Åª, Y‚Åª::Vars,
                               Œ±‚Åª::Vars, bctype, t, _...)
  atmos_boundary_state!(nf, bctup[bctype], m, Y‚Å∫, Œ±‚Å∫, n‚Åª, Y‚Åª, Œ±‚Åª,
                        bctype, t)
end

function atmos_boundary_state!(nf::CentralNumericalFluxDiffusive,
                               bctup::Tuple, m::AtmosModel, Y‚Å∫::Vars,
                               Œ£‚Å∫::Vars, Œ±‚Å∫::Vars, n‚Åª, Y‚Åª::Vars,
                               Œ£‚Åª::Vars, Œ±‚Åª::Vars, bctype, t, _...)
  atmos_boundary_state!(nf, bctup[bctype], m, Y‚Å∫, Œ£‚Å∫, Œ±‚Å∫, n‚Åª, Y‚Åª,
                        Œ£‚Åª, Œ±‚Åª, bctype, t)
end


abstract type BoundaryCondition
end

"""
    PeriodicBC <: BoundaryCondition

Assume that the topology is periodic and hence nothing special needs to be done at the boundaries.
"""
struct PeriodicBC <: BoundaryCondition end

# TODO: assert somewhere that the topology is actually periodic when using those
atmos_boundary_state!(_, ::PeriodicBC, _...) = nothing

"""
    NoFluxBC <: BoundaryCondition

Set the momentum at the boundary to be zero.

# TODO: This should be fixed later once BCs are figured out (likely want
# different things here?)

"""
struct NoFluxBC <: BoundaryCondition
end

function atmos_boundary_state!(::Rusanov, bc::NoFluxBC, m::AtmosModel,
                               Y‚Å∫::Vars, Œ±‚Å∫::Vars, n‚Åª, Y‚Åª::Vars,
                               Œ±‚Åª::Vars, bctype, t, _...)
  FT = eltype(Y‚Åª)
  Y‚Å∫.œÅ = Y‚Åª.œÅ
  Y‚Å∫.œÅu -= 2 * dot(Y‚Åª.œÅu, n‚Åª) * SVector(n‚Åª)
end

function atmos_boundary_state!(::CentralNumericalFluxDiffusive, bc::NoFluxBC,
                               m::AtmosModel, Y‚Å∫::Vars, Œ£‚Å∫::Vars,
                               Œ±‚Å∫::Vars, n‚Åª, Y‚Åª::Vars, Œ£‚Åª::Vars,
                               Œ±‚Åª::Vars, bctype, t, _...)
  FT = eltype(Y‚Åª)
  Y‚Å∫.œÅ = Y‚Åª.œÅ
  Y‚Å∫.œÅu -= 2 * dot(Y‚Åª.œÅu, n‚Åª) * SVector(n‚Åª)
  
  fill!(getfield(Œ£‚Å∫, :array), FT(0))
end

"""
    InitStateBC <: BoundaryCondition

Set the value at the boundary to match the `init_state!` function. This is
mainly useful for cases where the problem has an explicit solution.

# TODO: This should be fixed later once BCs are figured out (likely want
# different things here?)
"""
struct InitStateBC <: BoundaryCondition
end
function atmos_boundary_state!(::Rusanov, bc::InitStateBC, m::AtmosModel,
                               Y‚Å∫::Vars, Œ±‚Å∫::Vars, n‚Åª, Y‚Åª::Vars,
                               Œ±‚Åª::Vars, bctype, t, _...)
  init_state!(m, Y‚Å∫, Œ±‚Å∫, Œ±‚Å∫.coord, t)
end
function atmos_boundary_state!(::CentralNumericalFluxDiffusive, bc::InitStateBC,
                               m::AtmosModel, Y‚Å∫::Vars, Œ£‚Å∫::Vars,
                               Œ±‚Å∫::Vars, n‚Åª, Y‚Åª::Vars, Œ£‚Åª::Vars,
                               Œ±‚Åª::Vars, bctype, t, _...)
  init_state!(m, Y‚Å∫, Œ±‚Å∫, Œ±‚Å∫.coord, t)
end


"""
  DYCOMS_BC <: BoundaryCondition
  Prescribes boundary conditions for Dynamics of Marine Stratocumulus Case
"""
struct DYCOMS_BC{FT} <: BoundaryCondition
  C_drag::FT
  LHF::FT
  SHF::FT
end
function atmos_boundary_state!(::Rusanov, bc::DYCOMS_BC, m::AtmosModel,
                               Y‚Å∫::Vars, Œ±‚Å∫::Vars, n‚Åª, Y‚Åª::Vars,
                               Œ±‚Åª::Vars, bctype, t, Y‚ÇÅ‚Åª::Vars, Œ±‚ÇÅ::Vars)
  # Y‚Åª is the ùêò‚Åª state while Y‚Å∫ is the ùêò‚Å∫ state at an interface.
  # at the boundaries the ‚Åª, minus side states are the interior values
  # Y‚ÇÅ‚Åª is ùêò at the first interior nodes relative to the bottom wall
  FT = eltype(Y‚Å∫)
  # Get values from minus-side state
  œÅ‚Åª = Y‚Åª.œÅ
  UM, VM, WM = Y‚Åª.œÅu
  EM = Y‚Åª.œÅe
  QTM = Y‚Åª.moisture.œÅq_tot
  uM, vM, wM  = UM/œÅ‚Åª, VM/œÅ‚Åª, WM/œÅ‚Åª
  q_totM = QTM/œÅ‚Åª
  Un‚Åª = n‚Åª[1] * UM + n‚Åª[2] * VM + n‚Åª[3] * WM

  # Assign reflection wall boundaries (top wall)
  Y‚Å∫.œÅu = SVector(UM - 2 * n‚Åª[1] * Un‚Åª,
                      VM - 2 * n‚Åª[2] * Un‚Åª,
                      WM - 2 * n‚Åª[3] * Un‚Åª)

  # Assign scalar values at the boundaries
  Y‚Å∫.œÅ = œÅ‚Åª
  Y‚Å∫.moisture.œÅq_tot = QTM
end
function atmos_boundary_flux_diffusive!(nf::CentralNumericalFluxDiffusive,
                                        bc::DYCOMS_BC, atmos::AtmosModel,
                                        F‚Å∫, Y‚Å∫, Œ£‚Å∫, Œ±‚Å∫, n‚Åª,
                                        F‚Åª, Y‚Åª, Œ£‚Åª, Œ±‚Åª,
                                        bctype, t,
                                        Y‚ÇÅ‚Åª, Œ£‚ÇÅ‚Åª, Œ±‚ÇÅ‚Åª)
  FT = eltype(Y‚Å∫)

  # Y‚Åª is the ùêò‚Åª state while Y‚Å∫ is the ùêò‚Å∫ state at an interface.
  # at the boundaries the ‚Åª, minus side states are the interior values
  # Y‚ÇÅ‚Åª‚Åª is ùêò at the first interior nodes relative to the bottom wall
  # Get values from minus-side state
  œÅ‚Åª = Y‚Åª.œÅ
  U‚Åª, V‚Åª, W‚Åª = Y‚Åª.œÅu
  E‚Åª = Y‚Åª.œÅe
  QT‚Åª = Y‚Åª.moisture.œÅq_tot
  u‚Åª, v‚Åª, w‚Åª  = U‚Åª/œÅ‚Åª, V‚Åª/œÅ‚Åª, W‚Åª/œÅ‚Åª
  q_tot‚Åª = QT‚Åª/œÅ‚Åª
  Un‚Åª = n‚Åª[1] * U‚Åª + n‚Åª[2] * V‚Åª + n‚Åª[3] * W‚Åª

  # Assign reflection wall boundaries (top wall)
  Y‚Å∫.œÅu = SVector(U‚Åª - 2 * n‚Åª[1] * Un‚Åª,
                      V‚Åª - 2 * n‚Åª[2] * Un‚Åª,
                      W‚Åª - 2 * n‚Åª[3] * Un‚Åª)

  # Assign scalar values at the boundaries
  Y‚Å∫.œÅ = œÅ‚Åª
  Y‚Å∫.moisture.œÅq_tot = QT‚Åª
  # Assign diffusive fluxes at boundaries
  Œ£‚Å∫ = Œ£‚Åª
  if bctype != 1
    flux_diffusive!(atmos, F‚Å∫, Y‚Å∫, Œ£‚Å∫, Œ±‚Å∫, t)
  else
    # ------------------------------------------------------------------------
    # (<var>_FN) First node values (First interior node from bottom wall)
    # ------------------------------------------------------------------------
    z_FN             = Œ±‚ÇÅ‚Åª.coord[3]
    œÅ_FN             = Y‚ÇÅ‚Åª.œÅ
    U_FN, V_FN, W_FN = Y‚ÇÅ‚Åª.œÅu
    E_FN             = Y‚ÇÅ‚Åª.œÅe
    u_FN, v_FN, w_FN = U_FN/œÅ_FN, V_FN/œÅ_FN, W_FN/œÅ_FN
    windspeed_FN     = sqrt(u_FN^2 + v_FN^2 + w_FN^2)
    q_tot_FN         = Y‚ÇÅ‚Åª.moisture.œÅq_tot / œÅ_FN
    e_int_FN         = E_FN/œÅ_FN - windspeed_FN^2/2 - grav*z_FN
    TS_FN            = PhaseEquil(e_int_FN, œÅ_FN, q_tot_FN)
    T_FN             = air_temperature(TS_FN)
    q_vap_FN         = q_tot_FN - PhasePartition(TS_FN).liq
    # --------------------------
    # Bottom boundary quantities
    # --------------------------
    z‚Åª          = Œ±‚Åª.coord[3]
    q_tot‚Åª      = QT‚Åª/œÅ‚Åª
    windspeed   = sqrt(u‚Åª^2 + v‚Åª^2 + w‚Åª^2)
    e_int‚Åª      = E‚Åª/œÅ‚Åª - windspeed^2/2 - grav*z‚Åª
    TS‚Åª         = PhaseEquil(e_int‚Åª, œÅ‚Åª, q_tot‚Åª)
    q_vap‚Åª      = q_tot‚Åª - PhasePartition(TS‚Åª).liq
    T‚Åª          = air_temperature(TS‚Åª)
    # ----------------------------------------------------------
    # Extract components of diffusive momentum flux (minus-side)
    # ----------------------------------------------------------
    _, œÑ‚Åª = turbulence_tensors(atmos.turbulence, Y‚Åª, Œ£‚Åª, Œ±‚Åª, t)

    # ----------------------------------------------------------
    # Boundary momentum fluxes
    # ----------------------------------------------------------
    # Case specific for flat bottom topography, normal vector is n‚Éó = k‚Éó = [0, 0, 1]·µÄ
    # A more general implementation requires (n‚Éó ‚ãÖ ‚àáA) to be defined where A is replaced by the appropriate flux terms
    C_drag = bc.C_drag
    œÑ13‚Å∫  = - C_drag * windspeed_FN * u_FN
    œÑ23‚Å∫  = - C_drag * windspeed_FN * v_FN
    # Assign diffusive momentum and moisture fluxes
    # (i.e. œÅùõï terms)
    œÑ‚Å∫ = SHermitianCompact{3, FT, 6}(SVector(FT(0), œÑ‚Åª[2,1], œÑ13‚Å∫, FT(0), œÑ23‚Å∫,
                                             FT(0)))

    # ----------------------------------------------------------
    # Boundary moisture fluxes
    # ----------------------------------------------------------
    # really ‚àáq_tot is being used to store d_q_tot
    d_q_tot‚Å∫  = SVector(FT(0), FT(0), bc.LHF/(LH_v0))

    # ----------------------------------------------------------
    # Boundary energy fluxes
    # ----------------------------------------------------------
    # Assign diffusive enthalpy flux (i.e. œÅ(J+D) terms)
    d_h_tot‚Å∫ = SVector(FT(0), FT(0), bc.LHF + bc.SHF)

    flux_diffusive!(atmos, F‚Å∫, Y‚Å∫, œÑ‚Å∫, d_h_tot‚Å∫)
    flux_diffusive!(atmos.moisture, F‚Å∫, Y‚Å∫, d_q_tot‚Å∫)
  end
end

"""
  RayleighBenardBC <: BoundaryCondition

# Fields
$(DocStringExtensions.FIELDS)
"""
struct RayleighBenardBC{FT} <: BoundaryCondition
  "Prescribed bottom wall temperature [K]"
  T_bot::FT
  "Prescribed top wall temperature [K]"
  T_top::FT
end
# Rayleigh-Benard problem with two fixed walls (prescribed temperatures)
function atmos_boundary_state!(::Rusanov, bc::RayleighBenardBC, m::AtmosModel,
                               Y‚Å∫::Vars, Œ±‚Å∫::Vars, n‚Åª, Y‚Åª::Vars,
                               Œ±‚Åª::Vars, bctype, t,_...)
  # Dry Rayleigh Benard Convection
  @inbounds begin
    FT = eltype(Y‚Å∫)
    Y‚Å∫.œÅu = 2 * dot(Y‚Åª.œÅu, n‚Åª) * SVector(n‚Åª) - Y‚Åª.œÅu
    if bctype == 1
      œÅe_int‚Å∫ = Y‚Å∫.œÅ * cv_d * (bc.T_bot - T_0)
    else
      œÅe_int‚Å∫ = Y‚Å∫.œÅ * cv_d * (bc.T_top - T_0)
    end
    Y‚Å∫.œÅe = 2 * (œÅe_int‚Å∫ + Y‚Å∫.œÅ * Œ±‚Å∫.coord[3] * grav) - Y‚Åª.œÅe
    nothing
  end
end
function atmos_boundary_state!(::CentralNumericalFluxDiffusive, bc::RayleighBenardBC,
                               m::AtmosModel, Y‚Å∫::Vars, Œ£‚Å∫::Vars,
                               Œ±‚Å∫::Vars, n‚Åª, Y‚Åª::Vars, Œ£‚Åª::Vars,
                               Œ±‚Åª::Vars, bctype, t, _...)
  # Dry Rayleigh Benard Convection
  @inbounds begin
    FT = eltype(Y‚Åª)
    Y‚Å∫.œÅu = 2 * dot(Y‚Åª.œÅu, n‚Åª) * SVector(n‚Åª) - Y‚Åª.œÅu
    if bctype == 1
      œÅe_int‚Å∫ = Y‚Å∫.œÅ * cv_d * (bc.T_bot - T_0)
    else
      œÅe_int‚Å∫ = Y‚Å∫.œÅ * cv_d * (bc.T_top - T_0)
    end
    Y‚Å∫.œÅe = (œÅe_int‚Å∫ + Y‚Å∫.œÅ * Œ±‚Å∫.coord[3] * grav)
    nothing
  end
end


"""
  SurfaceDrivenBubbleBC <: BoundaryCondition

# Fields
$(DocStringExtensions.FIELDS)
"""
struct SurfaceDrivenBubbleBC{FT} <: BoundaryCondition
  "Prescribed MSEF Magnitude [W/m^2]"
  F‚ÇÄ::FT
  "Spatial Parameter [m]"
  œÉ::FT
  "Surface Heater Radius [m]"
  a::FT
  "Surface Heater Center [m]"
  x‚ÇÄ::FT
  "Time Cutoff [s]"
  t‚ÇÅ::FT
end
function atmos_boundary_state!(::Rusanov, bc::SurfaceDrivenBubbleBC, 
                               m::AtmosModel,
                               Y‚Å∫::Vars, 
                               Œ±‚Å∫::Vars, 
                               n‚Åª, 
                               Y‚Åª::Vars,
                               Œ±‚Åª::Vars, 
                               bctype, t,_...)
  FT = eltype(Y‚Å∫)
  @inbounds begin
    # Momentum b.c. prescribed (no flow across wall boundary)
    Y_bc  = dot(Y‚Åª.œÅu, n‚Åª)*SVector(n‚Åª)
    Y‚Å∫.œÅu = -Y‚Åª.œÅu + 2*Y_bc
  end
  nothing
end
function atmos_boundary_state!(::CentralNumericalFluxDiffusive, bc::SurfaceDrivenBubbleBC,
                               m::AtmosModel, 
                               Y‚Å∫::Vars, 
                               Œ£‚Å∫::Vars,
                               Œ±‚Å∫::Vars, 
                               n‚Åª, 
                               Y‚Åª::Vars, 
                               Œ£‚Åª::Vars,
                               Œ±‚Åª::Vars, 
                               bctype, t, _...)
  FT = eltype(Y‚Åª)
  kÃÇ  = Œ±‚Åª.orientation.‚àáŒ¶ / norm(Œ±‚Åª.orientation.‚àáŒ¶)  
  r = sqrt((Œ±‚Åª.coord[1]-bc.x‚ÇÄ)^2 + (Œ±‚Åª.coord[2]-bc.x‚ÇÄ)^2) 
  F‚ÇÄ =  bc.F‚ÇÄ*(1 - sign(t-bc.t‚ÇÅ))/2 
  @inbounds begin
    # Energy flux prescribed (diffusive flux through bottom wall)
    # MSEF ‚â° Moist Static Energy Flux
    if bctype == 1
      if r > bc.a 
        MSEF      = F‚ÇÄ * exp(-(r-bc.a)^2 / bc.œÉ^2)
        Œ£‚Å∫.‚àáh_tot = -Œ£‚Åª.‚àáh_tot + 2 * MSEF * kÃÇ
      else
        MSEF      = F‚ÇÄ
        Œ£‚Å∫.‚àáh_tot = -Œ£‚Åª.‚àáh_tot + 2 * MSEF * kÃÇ
      end
    end
  end
  nothing
end

